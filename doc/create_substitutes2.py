import enum
import re
from os import walk
from pathlib import Path
from typing import Dict, List, Optional, Union

import qgis
import qgis.core
import qgis.gui
import qgis.PyQt.QtCore
import qgis.PyQt.QtWidgets
import qgis.PyQt.QtGui

DIR_REPO = Path(__file__).parents[2]
DIR_SOURCE = DIR_REPO / 'doc/source'

DIR_ICONS = DIR_SOURCE / 'icons'

ICON_DIRS = [

]


class SourceType(enum.Flag):
    Icon = enum.auto()
    Link = enum.auto()


class Substitute(object):

    def __init__(self, name: str,
                 definition: Optional[str] = None,
                 stype: SourceType = SourceType.Link):
        self.name = name
        self.stype: SourceType = stype
        self.icon_path: Optional[Path] = None
        self.definition: Optional[str] = definition
        self.definition_raw: Optional[str] = None


def isSubDir(parentDir, subDir) -> bool:
    parentDir = Path(parentDir)
    subDir = Path(subDir)
    return subDir.as_posix().startswith(parentDir.as_posix())


class SubstituteCollection(object):

    def __init__(self,
                 source_root: Union[Path, str],
                 dir_rst_icons: Union[Path, str, None] = None):
        assert isinstance(source_root.is_dir())

        self.mIconSize: int = 28

        self.mSourceRoot = Path(source_root)

        if dir_rst_icons:
            assert isSubDir(self.mSourceRoot, dir_rst_icons)
        self.dir_rst_icons: Path = Path(dir_rst_icons)

        self.mSubstitutes: Dict[str, Substitute] = dict()

    def readRSTSubstitutionTxt(self, path: Path):
        assert path.is_file()
        assert isSubDir(self.mSourceRoot, path.parent)

    def addReplacement(self, name: str, link: str):
        sub = Substitute(name)

    def addSubstitute(self, substitute: Substitute):
        assert substitute.name not in self.mSubstitutes
        self.mSubstitutes[substitute.name] = substitute

    def readIconDir(self, source: Path):
        assert source.is_dir()

    def addManualDefinitions(self, source: Path):
        source = Path(source)
        assert source.is_file()

        with open(source, 'r', encoding='utf8') as f:
            lines: List[str] = f.readlines()
            lines = [l.split('#')[0] for l in lines]
            lines = [l for l in lines if l != ['']]
            s = ""

    def toRST(self, s: Substitute) -> str:

        if isinstance(s.definition_raw, str):
            return s.definition_raw

        if s.stype == SourceType.Link:
            # .. |Bitbucket| replace:: `Bitbucket <https://bitbucket.org>`_
            return f'.. |{self.name}| replace:: `{self.definition}`_'
        elif s.stype == SourceType.Icon:
            # .. |classinfo_remove| image:: icons/classinfo_remove.png
            #    :width: 28px
            assert isinstance(s.icon_path, Path)
            assert s.icon_path.is_file()

            if isSubDir(self.mSourceRoot, s.icon_path.parent):
                s = ""
                print(f'Copy {s.icon_path} to ')

            # lines = [f'.. |{s.name}| image:: {}']

            lines = []
            return '\n'.join(lines)
        else:
            raise NotImplementedError()


def create_API_links(collection: SubstituteCollection):
    objects = []
    for module in [
        qgis,
        qgis.core,
        qgis.gui,
        qgis.PyQt.QtCore,
        qgis.PyQt.QtWidgets,
        qgis.PyQt.QtGui,
    ]:
        s = ""
        for key in module.__dict__.keys():
            if re.search('^(Qgs|Q)', key):
                objects.append(key)
    objects = sorted(objects)

    collection.addSubstitute()
    lines = """# autogenerated file.

    .. |PyCharm| replace:: `PyCharm <https://www.jetbrains.com/pycharm/>`_
    .. |PyQtGraph| replace:: `PyQtGraph <https://pyqtgraph.readthedocs.io/en/latest/>`_
    .. |PyDev| replace:: `PyDev <https://www.pydev.org>`_
    .. |OSGeo4W| replace:: `OSGeo4W <https://www.osgeo.org/projects/osgeo4w>`_
    .. |Bitbucket| replace:: `Bitbucket <https://bitbucket.org>`_
    .. |Git| replace:: `Git <https://git-scm.com/>`_
    .. |GitHub| replace:: `GitHub <https://github.com/>`_
    .. |GDAL| replace:: `GDAL <https://www.gdal.org>`_
    .. |QtWidgets| replace:: `QtWidgets <https://doc.qt.io/qt-5/qtwidgets-index.html>`_
    .. |QtCore| replace:: `QtCore <https://doc.qt.io/qt-5/qtcore-index.html>`_
    .. |QtGui| replace:: `QtGui <https://doc.qt.io/qt-5/qtgui-index.html>`_
    .. |QGIS| replace:: `QGIS <https://www.qgis.org>`_
    .. |qgis.gui| replace:: `qgis.gui <https://api.qgis.org/api/group__gui.html>`_
    .. |qgis.core| replace:: `qgis.core <https://api.qgis.org/api/group__core.html>`_
    .. |Miniconda| replace:: `Miniconda <https://docs.conda.io/en/latest/miniconda.html>`_
    .. |miniconda| replace:: `miniconda <https://docs.conda.io/en/latest/miniconda.html>`_
    .. |Numba| replace:: `Numba <https://numba.pydata.org/>`_
    .. |Conda| replace:: `Conda <https://docs.anaconda.com/miniconda/>`_
    .. |conda| replace:: `conda <https://docs.anaconda.com/miniconda/>`_
    .. |conda-forge| replace:: `conda-forge <https://conda-forge.org/>`_
    .. |pip| replace:: `pip <https://pip.pypa.io/en/stable>`_

    # autogenerated singular forms
    """

    WRITTEN = []

    rx_qgis = re.compile('^Qgs|Qgis.*')

    for obj in objects:
        obj: str
        if obj in ['QtCore', 'QtGui', 'QtWidget']:
            continue
        print(obj)

        target = None
        if rx_qgis.match(obj):
            # https://qgis.org/api/classQgsProject.html
            target = "https://api.qgis.org/api/class{}.html".format(obj)
        elif obj.startswith('Q'):
            # https://doc.qt.io/qt-5/qwidget.html
            target = "https://doc.qt.io/qt-5/{}.html".format(obj.lower())
        else:
            continue

        singular = obj
        plural = obj + 's'

        line = None
        if singular.upper() not in WRITTEN:
            line = f'.. |{singular}|  replace:: `{singular} <{target}>`_'
            WRITTEN.append(singular.upper())

            if plural.upper() not in WRITTEN:
                line += f'\n.. |{plural}| replace:: `{plural} <{target}>`_'
                WRITTEN.append(plural.upper())

        if line:
            lines += '\n' + line


def read_rst_substitutes(file):
    """
    Returns sorted list of existing substitutions on a file
    :param file: string with path to file
    :return: list
    """

    # defines a pattern for a substitution
    # anything inside || except is preceded by ..
    s_pattern = re.compile(r"(?<!\.\. )\|([\w\d-]+)\|")
    s_title = re.compile(r"\.\. Substitutions definitions - AVOID EDITING "
                         r"PAST THIS LINE\n")
    subs = []
    with open(file, 'r+', encoding='utf-8') as f:
        pos = f.tell()
        line = f.readline()
        while line != "":
            if s_title.match(line) is not None:
                f.seek(pos - 4)
                f.truncate()
                break
            else:
                subs += s_pattern.findall(line)
                pos = f.tell()
                line = f.readline()
                # Making sure there is a newline at the end of the file
                if line == "" and len(subs) > 0:
                    f.seek(pos - 1)
                    if f.read() != "\n":
                        f.write("\n")
    list_subs = list(set(subs))
    list_subs.sort()
    return list_subs


def find_by_ext(folder, extension) -> List[Path]:
    """
    create list with absolute paths to all *.extension files inside
    folder and its sub-folders
    """
    found_files = [Path(dirpath) / f
                   for dirpath, dirnames, files in walk(folder)
                   for f in files if f.endswith('.' + extension)]
    return found_files


def create_substitutions(collection: SubstituteCollection):
    for file in find_by_ext(DIR_SOURCE, 'rst'):
        s_list = read_rst_substitutes(file)
        if len(s_list) > 0:
            s_definition = get_subst_definition(s_list, s_dict)
            append_subst(file, s_definition)


if __name__ == '__main__':
    collection = SubstituteCollection(DIR_SOURCE)

    path_manual = DIR_SOURCE / 'substitutions/substitutions_manual.txt'
    collection.addManualDefinitions(path_manual)
    create_API_links(collection)
    create_substitutions(collection)
